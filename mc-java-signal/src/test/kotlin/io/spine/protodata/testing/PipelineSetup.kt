/*
 * Copyright 2024, TeamDev. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Redistribution and use in source and/or binary forms, with or without
 * modification, must retain the above copyright notice and the following
 * disclaimer.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package io.spine.protodata.testing

import com.google.protobuf.Descriptors.FileDescriptor
import com.google.protobuf.compiler.PluginProtos.CodeGeneratorRequest
import io.spine.protodata.backend.Pipeline
import io.spine.protodata.plugin.Plugin
import io.spine.protodata.renderer.SourceFileSet
import io.spine.protodata.settings.SettingsDirectory
import java.nio.file.Path

/**
 * Creates a [Pipeline] for testing the given ProtoData [plugin].
 *
 * @param plugin
 *         the plugin to be passed to the created pipeline.
 * @param protoFiles
 *         descriptors of proto files included in the test.
 * @param settingsDir
 *         the directory to which store the settings for the given plugin.
 * @param inputRoot
 *         the root directory with the source code generated by `protoc`.
 * @param outputRoot
 *         the root directory to which the updated code will be placed.
 */
public open class PipelineSetup(
    public val plugin: Plugin,
    public val protoFiles: List<FileDescriptor>,
    settingsDir: Path,
    inputRoot: Path,
    outputRoot: Path
) {
    public val settings: SettingsDirectory
    public val sourceFileSet: SourceFileSet

    init {
        settingsDir.toFile().mkdirs()
        settings = SettingsDirectory(settingsDir)
        outputRoot.toFile().mkdirs()
        sourceFileSet = SourceFileSet.create(inputRoot, outputRoot)
    }

    public fun createPipeline(): Pipeline {
        val id = Pipeline.generateId()
        val request = createRequest()
        val pipeline = Pipeline(id, listOf(plugin), listOf(sourceFileSet), request, settings)
        return pipeline
    }

    private fun createRequest(): CodeGeneratorRequest {
        val builder = CodeGeneratorRequest.newBuilder()
        builder.addAllFileToGenerate(protoFiles.map { it.name })

        val dependencies = Dependencies(protoFiles).asList()
        builder.addAllProtoFile(dependencies.map { it.toProto() })

        val sourceFileDescriptors = protoFiles.map { it.toProto() }
        builder.addAllSourceFileDescriptors(sourceFileDescriptors)
        return builder.build()
    }
}

/**
 * Creates a list of dependencies for all Protobuf files specified by
 * the given descriptors.
 *
 * The resulting list contains all the imports of the files, and
 */
public class Dependencies(
    private val files: List<FileDescriptor>
) {
    private val collected: MutableSet<FileDescriptor> = mutableSetOf()

    init {
        files.forEach {
            it.addDependencies()
        }
    }

    public fun asList(): List<FileDescriptor> {
        val result = mutableListOf<FileDescriptor>()
        result.sortWith(FdComparator())
        return result.toList()
    }

    private fun FileDescriptor.addDependencies() {
        dependencies.forEach {
            it.addDependencies()
        }
        publicDependencies.forEach {
            it.addDependencies()
        }
        collected.add(this)
    }
}

/**
 * Compares [FileDescriptor] instances by their dependencies.
 */
private class FdComparator : Comparator<FileDescriptor> {

    @Suppress("ReturnCount")
    override fun compare(f1: FileDescriptor, f2: FileDescriptor): Int {
        // Sort by number of dependencies first.
        var result = f1.totalDependencies.compareTo(f2.totalDependencies)
        if (result != 0) return result

        // Then pull files that imported by others earlier.
        result =
            if (f1.isDependencyOf(f2)) -1
            else if (f2.isDependencyOf(f1)) 1
            else 0
        if (result != 0) return result

        // Then compare by names.
        result = f1.name.compareTo(f2.name)
        return result
    }
}

private val FileDescriptor.totalDependencies: Int
    get() = dependencies.size + publicDependencies.size

private fun FileDescriptor.isDependencyOf(another: FileDescriptor): Boolean =
    another.dependencies.contains(this) || another.publicDependencies.contains(this)
